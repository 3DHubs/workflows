name: tf-aws

on:
  workflow_call:
    inputs:
      terraform_version:
        description: "Terraform version"
        type: string
        required: false
        default: "1.1.6"
      path:
        description: "Directory containing Terraform code"
        type: string
        required: false
        default: "."

permissions:
  id-token: write
  contents: read

jobs:
  init:
    runs-on: ubuntu-latest
    outputs:
      session: ${{ steps.defs.outputs.session }}
      repository: ${{ steps.defs.outputs.repository }}
      accounts: ${{ steps.query.outputs.accounts }}
    steps:
      - uses: actions/checkout@v2
      - name: Definitions
        id: defs
        run: |
          repo="$(basename "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')"
          echo "::set-output name=session::$repo,${{ github.workflow }},${{ github.run_number }}"
          echo "::set-output name=repository::$repo"
      - name: Assume PR role
        if: ${{ github.event_name == 'pull_request' }}
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: eu-west-1
          role-to-assume: arn:aws:iam::312805905296:role/gha/gha_${{ steps.defs.outputs.repository }}_pr
          role-session-name: ${{ steps.defs.outputs.session }}
          mask-aws-account-id: false
      - name: Assume Push role
        if: ${{ github.ref == 'refs/heads/main' }}
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: eu-west-1
          role-to-assume: arn:aws:iam::312805905296:role/gha/gha_${{ steps.defs.outputs.repository }}_push
          role-session-name: ${{ steps.defs.outputs.session }}
          mask-aws-account-id: false
      - name: Get accounts
        id: query
        working-directory: ${{ inputs.path }}
        run: |
          # Accounts in our AWS organization
          aws organizations list-accounts | jq -c '[.Accounts[] | {name:.Name|ascii_downcase|gsub(" ";"-"), aws_account_id:.Id}]' | tee org_accounts.json
          # Accounts that have vars files in the repo
          find vars -name '*.tfvars' | jq -Rs '[split("\n")[] | select(length > 0) | sub("vars/"; "") | sub(".tfvars"; "")]' | tee var_accounts.json
          # Find the overlap
          accounts="$(python -c "import json; org = json.load(open('org_accounts.json')); var = json.load(open('var_accounts.json')); print(json.dumps([a for a in org if a['name'] in var]))")"
          echo "::set-output name=accounts::$accounts"

  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: ${{ inputs.terraform_version }}
      - name: validate
        working-directory: ${{ inputs.path }}
        run: |
          terraform init -backend=false
          terraform validate

  iamlive:
    runs-on: ubuntu-latest
    needs:
      - validate
    services:
      localstack:
        image: localstack/localstack:0.14.1
        ports:
          - 4566:4566
    steps:
      - uses: actions/checkout@v2
      - uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: ${{ inputs.terraform_version }}
      - name: iamlive
        if: ${{ github.event_name == 'pull_request' }}
        continue-on-error: true
        timeout-minutes: 3
        working-directory: ${{ inputs.path }}
        run: |
          # Download iamlive to figure out IAM permissions
          curl -fsSL "https://github.com/iann0036/iamlive/releases/download/v0.46.0/iamlive-v0.46.0-linux-amd64.tar.gz" \
            | tar -xz
          chmod +x iamlive

          # Start iamlive to listen for AWS calls
          echo -n "Starting iamlive. PID: "
          ./iamlive -mode csm -output-file iamlive.json -sort-alphabetical -background
          sleep 1

          # Run terraform against localstack to reproduce AWS calls
          export AWS_CSM_ENABLED=true
          export AWS_CSM_PORT=31000
          export AWS_CSM_HOST=127.0.0.1

          cat <<EOF >localstack_override.tf
          provider "aws" {
            access_key                  = "mock_access_key"
            region                      = "us-east-1"
            s3_use_path_style           = true
            secret_key                  = "mock_secret_key"
            skip_credentials_validation = true
            skip_metadata_api_check     = true
            skip_requesting_account_id  = true

            endpoints {
              apigateway     = "http://localhost:4566"
              cloudformation = "http://localhost:4566"
              cloudwatch     = "http://localhost:4566"
              dynamodb       = "http://localhost:4566"
              es             = "http://localhost:4566"
              firehose       = "http://localhost:4566"
              iam            = "http://localhost:4566"
              kinesis        = "http://localhost:4566"
              lambda         = "http://localhost:4566"
              route53        = "http://localhost:4566"
              redshift       = "http://localhost:4566"
              s3             = "http://localhost:4566"
              secretsmanager = "http://localhost:4566"
              ses            = "http://localhost:4566"
              sns            = "http://localhost:4566"
              sqs            = "http://localhost:4566"
              ssm            = "http://localhost:4566"
              stepfunctions  = "http://localhost:4566"
              sts            = "http://localhost:4566"
            }
          }
          EOF

          terraform init -backend=false
          terraform apply -auto-approve -input=false \
            -var boundary_policy_arn=arn:aws:iam::123412341234:policy/foo

          # Make iamlive dump derived policy
          sleep 10
          kill -HUP "$(pgrep iamlive)"
          sleep 10
          kill -TERM "$(pgrep iamlive)" || :

      - name: required-iam-policy
        if: ${{ github.event_name == 'pull_request' }}
        working-directory: ${{ inputs.path }}
        run: |
          if test -f iamlive.json; then
          cat <<EOF
          ------------------------------------------
          Required IAM policy to run terraform apply
          ------------------------------------------
          EOF
          cat iamlive.json
          else
          echo "No iamlive policy generated."
          fi

  run:
    runs-on: ubuntu-latest
    needs:
      - init
      - validate
    strategy:
      fail-fast: false
      matrix:
        env: ${{ fromJSON(needs.init.outputs.accounts) }}
    steps:
      - uses: actions/checkout@v2
      - name: Assume PR role
        if: ${{ github.event_name == 'pull_request' }}
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: eu-west-1
          role-to-assume: arn:aws:iam::312805905296:role/gha/gha_${{ needs.init.outputs.repository }}_pr
          role-session-name: ${{ needs.init.outputs.session }}
          mask-aws-account-id: false
      - name: Assume Push role
        if: ${{ github.ref == 'refs/heads/main' }}
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: eu-west-1
          role-to-assume: arn:aws:iam::312805905296:role/gha/gha_${{ needs.init.outputs.repository }}_push
          role-session-name: ${{ needs.init.outputs.session }}
          mask-aws-account-id: false
      - uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: ${{ inputs.terraform_version }}
      - name: init
        working-directory: ${{ inputs.path }}
        env:
          scope: ${{ github.ref == 'refs/heads/main' && 'apply' || 'plan' }}
        run: |
          cat <<EOF >_provider_override.tf
          terraform {
            backend "s3" {}
          }
          provider "aws" {
            assume_role {
              role_arn     = "arn:aws:iam::${{ matrix.env.aws_account_id }}:role/gha/gha_${{ needs.init.outputs.repository }}_$scope"
              session_name = "${{ needs.init.outputs.session }}"
            }
            default_tags {
              tags = {
                Environment = "${{ matrix.env.name }}"
                GithubRepo = "${{ github.repository }}"
                GithubPath = "${{ inputs.path }}"
                GithubWorkflow = "${{ github.workflow }}"
              }
            }
          }
          EOF
          cat <<EOF >_workflow.tfvars
          boundary_policy_arn = "arn:aws:iam::${{ matrix.env.aws_account_id }}:policy/gha/gha_${{ needs.init.outputs.repository }}"
          EOF

          terraform init \
            -backend-config="bucket=tfstate.mgmt.hubs.com" \
            -backend-config="key=${{ needs.init.outputs.repository }}" \
            -backend-config="workspace_key_prefix=env" \
            -backend-config="dynamodb_table=tflock"

          terraform workspace select "${{ matrix.env.name }}" || terraform workspace new "${{ matrix.env.name }}"

      - name: plan
        working-directory: ${{ inputs.path }}
        env:
          tfvars: vars/${{ matrix.env.name }}.tfvars
        run: terraform plan -no-color -out=tfplan -var-file="$tfvars" -var-file="_workflow.tfvars"
      - name: apply
        if: ${{ github.ref == 'refs/heads/main' }}
        working-directory: ${{ inputs.path }}
        run: if test -f tfplan; then terraform apply -no-color tfplan; fi
